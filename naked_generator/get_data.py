import pathlib
import json
import math
import re

from .lib import utils
from .schema import Message, get_types

types_size = {
    "bool": 1,
    "int8": 8,
    "uint8": 8,
    "int16": 16,
    "uint16": 16,
    "int32": 32,
    "uint32": 32,
    "int64": 64,
    "uint64": 64,
    "float32": 32,
    "float64": 64,
}

# def count_message_size(network):
#     messages_size = {}
#     custom_types = network.get_types()
#     for topic_name, _ in network.get_topics().items():
#         for message_name, message_contents in network.get_messages_by_topic(topic_name).items():
#             messages_size[message_name] = []

#             for field_name, field in message_contents['contents'].items():
#                 if isinstance(field, list):
#                     messages_size[message_name].append( { 'field_name': field_name, 'field_type': 'enum', 'bit_size': math.ceil( math.log2( len(field) ) ) } )
#                 elif field in types_size:
#                     messages_size[message_name].append( { 'field_name': field_name, 'field_type': field, 'bit_size': types_size[field] } )
#                 elif field in custom_types:
#                     if custom_types[field]['type'] == 'bitset':
#                         if 'size' in custom_types[field]:
#                             messages_size[message_name].append( { 'field_name': field_name, 'field_type': 'bitset', 'bit_size': math.ceil(custom_types[field]['size'] / 8) } )
#                         else:
#                             messages_size[message_name].append( { 'field_name': field_name, 'field_type': 'bitset', 'bit_size': math.ceil( len(custom_types[field]['items']) / 8 ) * 8 } )
#                     elif custom_types[field]['type'] == 'enum':
#                         messages_size[message_name].append( { 'field_name': field_name, 'field_type': 'enum', 'bit_size': math.ceil( math.log2( len(custom_types[field]['items']) ) ) } )
#                 else:
#                     raise Exception(f'Unknown type {field}')

#     new_messages_size = {}
#     for message_name, message_content in messages_size.items():
#         messages_sorted = sorted(message_content, key=lambda d: d['bit_size'], reverse=True)
#         messages_size[message_name] = messages_sorted
#         indice = 0
#         new_messages_size[message_name] = {0: [], 1: [], 2: [], 3: [], 4: [], 5: [], 6: [], 7: []}
#         for field in messages_sorted:

#             field['index'] = indice // 8

#             if field['bit_size'] % 8 == 0:
#                 field['shift'] = 0
#             else:
#                 field['shift'] = 8 - (indice % 8) - field['bit_size']

#             indice += field['bit_size']

#             new_messages_size[message_name][field['index']].append({ 'name': field['field_name'], 'shift': field['shift'] })

#     return new_messages_size


def get_data_from_network(network, output_path: pathlib.Path):
    # messages = count_message_size(network)
    custom_types = network.get_types()
    messages = []
    messages_names = []
    types = {}
    messages_size = {}

    for custom_type_name, custom_type_content in custom_types.items():
        types[custom_type_name] = get_types(custom_type_content)

    for topic_name, _ in network.get_topics().items():
        for message_name, message_content in network.get_messages_by_topic(
            topic_name
        ).items():
            if (
                message_content.get("split_senders", False) == True
            ):  # Check if the message was generated by splitting senders
                message_name = re.sub(
                    r"_\d+$", "", message_name
                )  # Use regex to remove _<number> at the end of the name
            if not message_name in messages_names:
                messages_names.append(message_name)
                messages.append(
                    Message(types, message_name, message_content["contents"])
                )

    for message in messages:
        message.fields = sorted(message.fields, key=lambda d: d.bit_size, reverse=True)
        messages_size[message.name] = {
            0: [],
            1: [],
            2: [],
            3: [],
            4: [],
            5: [],
            6: [],
            7: [],
        }
        indice = 0
        for field in message.fields:

            if field.bit_size % 8 == 0:
                field.shift = 0
            else:
                field.shift = 8 - (indice % 8) - field.bit_size

            messages_size[message.name][indice // 8].append(field)

            indice += field.bit_size

    # schema = Schema(messages)

    utils.create_subtree(output_path)
    # with open(output_path / "schema.json", 'w') as f:
    #     json.dump(messages_size, f, indent=4)
    # print(f'Generated schema for {network.name} in {output_path / "schema.json"}')

    return messages, messages_size


# class Schema:


#     def __init__(self, schema: dict):
#         self.byte = {
#             0: {},
#             1: {},
#             2: {},
#             3: {},
#             4: {},
#             5: {},
#             6: {},
#             7: {}
#         }

#         for message_name, message_content in schema.items():
#             for field in message_content:
#                 if message_name in self.byte[field['index']]:
#                     self.byte[field['index']][message_name].append(field)
#                 else:
#                     self.byte[field['index']][message_name] = [field]

# print(self.byte)

# class Field:
#     def __init__()
