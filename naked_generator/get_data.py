import pathlib
import json
import math
import re

from .lib import utils
from .schema import Message, get_types

types_size = {
        'bool': 1,
        'int8': 8,
        'uint8': 8,
        'int16': 16,
        'uint16': 16,
        'int32': 32,
        'uint32': 32,
        'int64': 64,
        'uint64': 64,
        'float32': 32,
        'float64': 64
    }

# def count_message_size(network):
#     messages_size = {}
#     custom_types = network.get_types()
#     for topic_name, _ in network.get_topics().items():
#         for message_name, message_contents in network.get_messages_by_topic(topic_name).items():
#             messages_size[message_name] = []

#             for field_name, field in message_contents['contents'].items():
#                 if isinstance(field, list):
#                     messages_size[message_name].append( { 'field_name': field_name, 'field_type': 'enum', 'bit_size': math.ceil( math.log2( len(field) ) ) } )
#                 elif field in types_size:
#                     messages_size[message_name].append( { 'field_name': field_name, 'field_type': field, 'bit_size': types_size[field] } )
#                 elif field in custom_types:
#                     if custom_types[field]['type'] == 'bitset':
#                         if 'size' in custom_types[field]:
#                             messages_size[message_name].append( { 'field_name': field_name, 'field_type': 'bitset', 'bit_size': math.ceil(custom_types[field]['size'] / 8) } )
#                         else:
#                             messages_size[message_name].append( { 'field_name': field_name, 'field_type': 'bitset', 'bit_size': math.ceil( len(custom_types[field]['items']) / 8 ) * 8 } )
#                     elif custom_types[field]['type'] == 'enum':
#                         messages_size[message_name].append( { 'field_name': field_name, 'field_type': 'enum', 'bit_size': math.ceil( math.log2( len(custom_types[field]['items']) ) ) } )
#                 else:
#                     raise Exception(f'Unknown type {field}')

#     new_messages_size = {}
#     for message_name, message_content in messages_size.items():
#         messages_sorted = sorted(message_content, key=lambda d: d['bit_size'], reverse=True)
#         messages_size[message_name] = messages_sorted
#         indice = 0
#         new_messages_size[message_name] = {0: [], 1: [], 2: [], 3: [], 4: [], 5: [], 6: [], 7: []}
#         for field in messages_sorted:

#             field['index'] = indice // 8

#             if field['bit_size'] % 8 == 0:
#                 field['shift'] = 0
#             else:
#                 field['shift'] = 8 - (indice % 8) - field['bit_size']

#             indice += field['bit_size']

#             new_messages_size[message_name][field['index']].append({ 'name': field['field_name'], 'shift': field['shift'] })

#     return new_messages_size

def get_data_from_network(network, output_path: pathlib.Path):
    # messages = count_message_size(network)
    custom_types = network.get_types()
    messages = []
    messages_names = []
    types = {}
    messages_size = {}

    for custom_type_name, custom_type_content in custom_types.items():
        types[custom_type_name] = get_types(custom_type_content)

    for topic_name, _ in network.get_topics().items():
        for message_name, message_content in network.get_messages_by_topic(topic_name).items():
            if message_content.get("split_senders", False) == True: # Check if the message was generated by splitting senders
                message_name = re.sub(r'_\d+$', '', message_name) # Use regex to remove _<number> at the end of the name
            if not message_name in messages_names:
                messages_names.append(message_name)
                messages.append(Message(types, message_name, message_content["contents"]))

    for message in messages:
        message.fields = sorted(message.fields, key=lambda d: d.bit_size, reverse=True)
        messages_size[message.name] = {0: [], 1: [], 2: [], 3: [], 4: [], 5: [], 6: [], 7: []}
        indice = 0
        for field in message.fields:

            if field.bit_size % 8 == 0:
                field.shift = 0
            else:
                field.shift = 8 - (indice % 8) - field.bit_size

            messages_size[message.name][indice // 8].append(field)

            indice += field.bit_size



    # schema = Schema(messages)

    utils.create_subtree(output_path)
    # with open(output_path / "schema.json", 'w') as f:
    #     json.dump(messages_size, f, indent=4)
    # print(f'Generated schema for {network.name} in {output_path / "schema.json"}')

    return messages, messages_size

# class Schema:


#     def __init__(self, schema: dict):
#         self.byte = {
#             0: {},
#             1: {},
#             2: {},
#             3: {},
#             4: {},
#             5: {},
#             6: {},
#             7: {}
#         }

#         for message_name, message_content in schema.items():
#             for field in message_content:
#                 if message_name in self.byte[field['index']]:
#                     self.byte[field['index']][message_name].append(field)
#                 else:
#                     self.byte[field['index']][message_name] = [field]

        # print(self.byte)

# class Field:
#     def __init__()