import math
import re

"""
    struct format = {
        "name": "struct_name",
        "fields": {
            "field_name": "field_type",
            ...
        }
        ...
    }
    
    enum format = {
        "name": "enum_name",
        "items": [ITEM_NAME, ...]
    }
"""

"""
    There is only 1 instance per type, if you modify a type, e.g. the name, the change will propagate
"""

types_size = {}
types = {}


def get_types(custom_type: dict):
    match custom_type["type"]:
        case "bitset":
            return BitSet(custom_type)
        case "enum":
            return Enum(custom_type["items"])


class Schema:
    def __init__(self, network):
        self.messages = []
        messages_names = []
        self.types = {}
        self.messages_size = {}

        for custom_type_name, custom_type_content in network.get_types().items():
            self.types[custom_type_name] = get_types(custom_type_content)

        for topic_name, _ in network.get_topics().items():
            for message_name, message_content in network.get_messages_by_topic(
                topic_name
            ).items():
                if (
                    message_content.get("split_senders", False) == True
                ):  # Check if the message was generated by splitting senders
                    message_name = re.sub(
                        r"_\d+$", "", message_name
                    )  # Use regex to remove _<number> at the end of the name
                if not message_name in messages_names:
                    messages_names.append(message_name)
                    self.messages.append(
                        Message(
                            network.name,
                            self.types,
                            message_name,
                            message_content["contents"],
                            message_content.get("frequency", -1),
                        )
                    )

        for message in self.messages:
            message.fields = sorted(
                message.fields, key=lambda d: d.bit_size, reverse=True
            )
            self.messages_size[message.name] = {
                0: [],
                1: [],
                2: [],
                3: [],
                4: [],
                5: [],
                6: [],
                7: [],
            }
            indice = 0
            inizio = 8
            for field in message.fields:

                if field.bit_size % 8 == 0:
                    field.shift = 0
                else:
                    if (indice % 8) + field.bit_size >= 8:
                        indice += 8 - (indice % 8)
                        field.shift = 8 - (indice % 8) - field.bit_size
                        inizio = 8
                    else:
                        field.shift = 8 - (indice % 8) - field.bit_size
                    mask = 0
                    if isinstance(field.type, Enum) or field.type.name == "bool":
                        for bit in reversed(range(inizio)):
                            if bit >= field.shift:
                                mask = mask | (1 << bit)
                                inizio = inizio - 1
                        field.bit_mask = mask

                # if field.bit_size > 8:
                #     field.byte_size = math.ceil(field.bit_size / 8)
                self.messages_size[message.name][indice // 8].append(field)

                indice += field.bit_size

            message.size = math.ceil(indice / 8)


class Message:
    def __init__(
        self,
        filename,
        custom_types: dict,
        message_name: str,
        message_content: dict,
        frequency,
    ):
        global types_size
        types_size = {
            "bool": 1,
            "int8": 8,
            "uint8": 8,
            "int16": 16,
            "uint16": 16,
            "int32": 32,
            "uint32": 32,
            "int64": 64,
            "uint64": 64,
            "float32": 32,
            "float64": 64,
        }

        self.name = f"{filename}_{message_name}"
        self.fields = []
        self.size = None
        self.frequency = frequency

        for field_name, field_content in message_content.items():
            self.fields.append(Field(field_name, field_content, custom_types))


class Field:
    def __init__(self, field_name: str, field_type, types: dict):
        self.name = (
            field_name if not ":" in field_name else field_name.split(":")[1].strip()
        )
        self._custom_type = (
            field_type if not ":" in field_name else field_name.split(":")[0].strip()
        )

        if isinstance(self._custom_type, list):
            if not self.name in types:
                types[self.name] = Enum(self._custom_type)
            self.type = types[self.name]
        elif self._custom_type in types_size:
            self.type = Number(self._custom_type)
        elif not isinstance(self._custom_type, list):
            if not self._custom_type in types:
                types[self._custom_type] = Enum(field_type)
            self.type = types[self._custom_type]

        self.bit_size = self.type._bit_size
        self.byte_size = math.ceil(self.bit_size / 8)
        self.shift = None
        self.bit_mask = None


class BitSet:
    def __init__(self, field_content):
        self.name = None
        self.content = []

        if "items" in field_content:
            self.content = [
                Item(field, index) for index, field in enumerate(field_content["items"])
            ]
            self.size = len(field_content["items"])
        elif "size" in field_content:
            self.size = field_content["size"]
        else:
            raise Exception("Invalid bitset format")

        self._bit_size = math.ceil(self.size / 8) * 8
        self.byte_size = self._bit_size // 8 if self._bit_size // 8 != 0 else 1
        self.superclass = []
        if "contents" in field_content:
            for bitset in field_content["contents"]:
                self.superclass.append(str(bitset))


class Number:
    def __init__(self, field):
        self.name = field
        self._bit_size = types_size[field]


class Enum:
    def __init__(self, field_content):
        self.name = None
        self.content = []

        for index, enum_item in enumerate(field_content):
            self.content.append(Item(enum_item, index))

        self._bit_size = math.ceil(math.log2(len(self.content)))


class Item:
    def __init__(self, item, index):
        self.item = item
        self.index = index
